Section Header

  + name      := TRIANGULATE;
  - copyright := "2014 Benjamin Chetioui";
  - author    := "Benjamin Chetioui";
  - comment   := "Mod√©lisation 3D de formes";

Section Inherit

  + parent_area:Expanded AREA;
  + parent_g_expr:Expanded G_EXPR;

Section Public

  /*- translating:FAST_ARRAY(LINES) :=
  (
    + result:FAST_ARRAY(LINES);
    + new_lines, tmp:LINES;
    + new_point:POINT;
    + nb_points:INTEGER;
    + local:INTEGER;
    + x,y,z:INTEGER;
    + z_min:INTEGER;

    IO.read_integer;
    nb_points := IO.last_integer;
    result := FAST_ARRAY(LINES).create_with_capacity(nb_points);
    new_point := POINT.clone;
    new_lines := LINES.clone;

    IO.read_integer;
    nb_points := IO.last_integer;
    nb_points.println;

    1.to nb_points do { i:INTEGER;
      IO.read_integer;
      x := IO.last_integer;
      IO.read_integer;
      y := IO.last_integer;
      IO.read_integer;
      z := IO.last_integer;
      x.print;
      " ".print;
      y.print;
      " ".print;
      z.println;
      "1".println;
      "0 0 0".println;
    };
  );*/

  + nb_objects:INTEGER := 0;

  // Initializing our lines and points to draw using standard input.
  - my_lines:FAST_ARRAY(LINES) :=
  (
    + result:FAST_ARRAY(LINES);
    + new_lines, tmp:LINES;
    + new_point:POINT;
    + nb_points:INTEGER;
    + x,y,z:INTEGER;

    IO.read_integer;
    nb_points := IO.last_integer;
    result := FAST_ARRAY(LINES).create_with_capacity(nb_points);
    new_point := POINT.clone;
    new_lines := LINES.clone;

    1.to nb_points do { i:INTEGER;
      IO.read_integer;
      x := IO.last_integer;
      IO.read_integer;
      y := IO.last_integer;
      IO.read_integer;
      z := IO.last_integer;
      new_point.create(x,y,z);
      new_lines.create(new_point, nb_points-1);
      tmp := new_lines.clone;
      result.add_last(tmp);
      nb_objects := nb_objects + 1;
    };
    result
  );

  - min (p1,p2:LINES) :LINES <-
  (
    + toreturn:LINES;
    
    toreturn := p1;

    (p1.src.x >= p2.src.x).if {
      (p1.src.x = p2.src.x).if {
        (p1.src.y > p2.src.y).if {
          toreturn := p2;
        };
      } 
      else {
        toreturn := p2;
      };
    };
    toreturn
  );
  
  - order <-
  (
    + local,tmp:LINES;
    + count,count2,pos:INTEGER;
        
    count := nb_objects - 1;
    count2 := nb_objects - 2;

    0.to count2 do { i:INTEGER;
      pos := i;
      local := my_lines.item i;
      i.to count do { j:INTEGER;
        tmp := min(local, (my_lines.item j));
        ((tmp.src.x != local.src.x) || {tmp.src.y != local.src.y}).if {
          local := tmp;
          pos := j;
        };
      };
      my_lines.put (my_lines.item i) to pos;
      my_lines.put (local) to i;
    };
  );

  - main <-
  (
    my_lines;
    debugging;
    " ".println;
    order;
    debugging;
  );

  - debugging <-
  (
    0.to nb_objects do { i:INTEGER;
      (my_lines.item i).src.debug;
    };
  );

  // Initializing our lines and points to draw using standard input.
  /*- translating <-
  (
    + nb_points:INTEGER;
    + x,y,z:INTEGER;

    IO.read_integer;
    nb_points := IO.last_integer;

    nb_points.println;
    1.to nb_points do { i:INTEGER;
      IO.read_integer;
      x := IO.last_integer;
      IO.read_integer;
      y := IO.last_integer;
      IO.read_integer;
      z := IO.last_integer;
      (i != 1).if {
        1.println;
        x.print;
        " ".print;
        y.print;
        " ".print;
        z.println;
        "".println;
      };
      (i != nb_points).if {
        x.print;
        " ".print;
        y.print;
        " ".print;
        z.println;
      }
      else {
        x.print;
        " ".print;
        y.print;
        " ".print;
        z.println;
        "0".println;
      };
    };
  );*/
